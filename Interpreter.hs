[1mdiff --git a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/bin/lang-exe b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/bin/lang-exe[m
[1mindex e2a2032..b8af926 100644[m
Binary files a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/bin/lang-exe and b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/bin/lang-exe differ
[1mdiff --git a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.a b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.a[m
[1mindex a805323..49f0720 100644[m
Binary files a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.a and b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.a differ
[1mdiff --git a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe-ghc8.8.4.so b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe-ghc8.8.4.so[m
[1mindex 382a918..3975808 100644[m
Binary files a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe-ghc8.8.4.so and b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/libHSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe-ghc8.8.4.so differ
[1mdiff --git a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.conf b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.conf[m
[1mdeleted file mode 100644[m
[1mindex c82affd..0000000[m
[1m--- a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe.conf[m
[1m+++ /dev/null[m
[36m@@ -1,41 +0,0 @@[m
[31m-name:                 lang[m
[31m-version:              0.1.0.0[m
[31m-visibility:           public[m
[31m-id:                   lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe[m
[31m-key:                  lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe[m
[31m-license:              BSD-3-Clause[m
[31m-copyright:            2021 Author name here[m
[31m-maintainer:           example@example.com[m
[31m-author:               Author name here[m
[31m-homepage:             https://github.com/githubuser/lang#readme[m
[31m-description:[m
[31m-    Please see the README on GitHub at <https://github.com/githubuser/lang#readme>[m
[31m-[m
[31m-abi:                  731721d47cc135454cbfaf15efa2bf0c[m
[31m-exposed:              True[m
[31m-exposed-modules:[m
[31m-    CCExc CState Environment FunParser FunSyntax Interpreter Parsing[m
[31m-[m
[31m-hidden-modules:       Paths_lang[m
[31m-import-dirs:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe"[m
[31m-[m
[31m-library-dirs:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4/lang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe"[m
[31m-[m
[31m-dynamic-library-dirs:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/lib/x86_64-linux-ghc-8.8.4"[m
[31m-[m
[31m-data-dir:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/share/x86_64-linux-ghc-8.8.4/lang-0.1.0.0"[m
[31m-[m
[31m-hs-libraries:         HSlang-0.1.0.0-I6GnE3ne2ULBziaMLhbHDe[m
[31m-depends:[m
[31m-    CC-delcont-0.2.1.0-7oCrSV9gweO1ar9PQ3I6Vp base-4.13.0.0[m
[31m-    containers-0.6.2.1 mtl-2.2.2 unix-2.7.2.2[m
[31m-[m
[31m-haddock-interfaces:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/doc/lang-0.1.0.0/lang.haddock"[m
[31m-[m
[31m-haddock-html:[m
[31m-    "/mnt/c/Users/Blade/Documents/OxCS/4th Year Proj/concurrent-fp/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/doc/lang-0.1.0.0"[m
[1mdiff --git a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/package.cache b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/package.cache[m
[1mindex d569be4..b3cae5c 100644[m
Binary files a/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/package.cache and b/.stack-work/install/x86_64-linux/8cdb7c01c61379baa5b2837611a8d2fb3f850d1861b2491d8477dd76d5414e84/8.8.4/pkgdb/package.cache differ
[1mdiff --git a/.stack-work/stack.sqlite3 b/.stack-work/stack.sqlite3[m
[1mindex aafafa5..78fea72 100644[m
Binary files a/.stack-work/stack.sqlite3 and b/.stack-work/stack.sqlite3 differ
[1mdiff --git a/lang/app/Main.hs b/lang/app/Main.hs[m
[1mindex 342da27..ade1761 100644[m
[1m--- a/lang/app/Main.hs[m
[1m+++ b/lang/app/Main.hs[m
[36m@@ -6,4 +6,4 @@[m [mimport FunParser[m
 import Parsing[m
 [m
 main :: IO ()[m
[31m-main = dialog funParser obey (init_env, init_cst)[m
[32m+[m[32mmain = putStr "32" --dialog funParser obey (init_env, init_cst)[m
[1mdiff --git a/lang/lang.cabal b/lang/lang.cabal[m
[1mindex 696f75c..822a88f 100644[m
[1m--- a/lang/lang.cabal[m
[1m+++ b/lang/lang.cabal[m
[36m@@ -39,7 +39,8 @@[m [mlibrary[m
   hs-source-dirs:[m
       src[m
   build-depends:[m
[31m-      CC-delcont[m
[32m+[m[32m      fclabels[m
[32m+[m[32m    , lens[m
     , base >=4.7 && <5[m
     , containers[m
     , mtl[m
[36m@@ -54,7 +55,7 @@[m [mexecutable lang-exe[m
       app[m
   ghc-options: -threaded -rtsopts -with-rtsopts=-N[m
   build-depends:[m
[31m-      CC-delcont[m
[32m+[m[32m      fclabels[m
     , base >=4.7 && <5[m
     , containers[m
     , lang[m
[1mdiff --git a/lang/package.yaml b/lang/package.yaml[m
[1mindex 3c943f7..1629635 100644[m
[1m--- a/lang/package.yaml[m
[1m+++ b/lang/package.yaml[m
[36m@@ -23,9 +23,10 @@[m [mdependencies:[m
 - base >= 4.7 && < 5[m
 - containers[m
 - unix[m
[31m-- CC-delcont >= 0[m
[32m+[m[32m- fclabels > 2[m
 - mtl[m
 [m
[32m+[m
 library:[m
   source-dirs: src[m
 [m
[1mdiff --git a/lang/src/Interpreter.hs b/lang/src/Interpreter.hs[m
[1mindex 537066d..0a0ec5a 100644[m
[1m--- a/lang/src/Interpreter.hs[m
[1m+++ b/lang/src/Interpreter.hs[m
[36m@@ -1,8 +1,9 @@[m
 {- [m
   Monadic definitional interpreter.[m
 -}[m
[32m+[m[32m{-# LANGUAGE TemplateHaskell, TypeOperators #-}[m
 [m
[31m-module Interpreter(obey, init_cst, init_env) where[m
[32m+[m[32mmodule Interpreter({-obey, init_GlobState, init_env-}) where[m
 [m
 import Parsing[m
 import FunSyntax[m
[36m@@ -11,57 +12,26 @@[m [mimport Environment[m
 import CState[m
 [m
 import Data.List (intercalate)[m
[32m+[m[32mimport Control.Lens[m
[32m+[m
[32m+[m[32mimport Data.Label[m
[32m+[m[32mimport Data.Label.Monadic[m
 [m
 import Control.Monad[m
[32m+[m[32mimport Control.Monad.State[m
 import Control.Monad.Trans (lift)[m
 import CCExc[m
 [m
 import Debug.Trace[m
 [m
[31m--- TODO: A more algebraic approach, to allow easy combination of ``pure"[m
[31m---       algebraic effects (i.e. create a class for state as a first step)[m
[31m-[m
[31m------ State monad -----[m
[31m-newtype State s a = State { runS :: s -> (a, s) }[m
[31m-[m
[31m-instance Monad (State s) where[m
[31m-  return a = State $ \s -> (a, s)[m
[31m-  (State sm) >>= f = State $ \s -> [m
[31m-    let (a, newS) = sm s[m
[31m-        (State rs) = f a [m
[31m-    in rs newS[m
[31m-[m
[31m-instance Functor (State s) where[m
[31m-  fmap f (State m) = State $ \s -> [m
[31m-    let (a, newS) = m s[m
[31m-    in (f a, newS)[m
[31m-[m
[31m-instance Applicative (State s) where[m
[31m-  pure = return[m
[31m-[m
[31m-instance MonadFail (State s) where[m
[31m-  fail = error "state matching failed"[m
[31m-[m
[31m------ Operations for the state monad -----[m
[31m-get :: ChanID -> State CST (CType Value (Kont Value))[m
[31m-get l = State $ \(CST chs) -> (contents chs l, CST chs)[m
[31m-[m
[31m-put :: ChanID -> CType Value (Kont Value) -> State CST ()[m
[31m-put l ct = State $ \(CST chs) -> ((), CST $ update chs l ct)[m
[31m-[m
[31m-new :: State CST ChanID[m
[31m-new = State $ \(CST chs) -> let (l, chs') = fresh chs in (l, CST chs')[m
[31m-[m
 ----- Helper types -----[m
[31m-type Env       = Environment Value[m
[31m-[m
[31m-newtype CST    = CST (ChanState Value (Kont Value))[m
[32m+[m[32mtype Env          = Environment Value[m
 [m
[31m-type Kont      = CC PromptT (State CST)[m
[31m-type PromptT   = P2 Value Value[m
[31m-type ProgState = (Env, CST)[m
[31m-type Arg       = String[m
[31m-type Name      = String[m
[32m+[m[32mtype Kont         = CC PromptT (State GlobState)[m
[32m+[m[32mtype PromptT      = P2 Value Value[m
[32m+[m[32mtype ProgState    = (Env, GlobState)[m
[32m+[m[32mtype Arg          = String[m
[32m+[m[32mtype Name         = String[m
 [m
 -- Patterns in our language are Expressions themselves; see the comment[m
 -- for the `matchPat' function[m
[36m@@ -81,9 +51,28 @@[m [mdata Value =[m
   -- Below we have denotable but not expressible values[m
   | Resume (Kont Value)[m
   | Halted ChanID[m
[31m-  | Waiting ChanID              [m
[32m+[m[32m  | Waiting ChanID[m[41m     [m
[32m+[m
[32m+[m[32m----- State and its labels (lenses) -----[m
[32m+[m[32mdata GlobState = GlobState { _cst   :: ChanState Value (Kont Value),[m[41m [m
[32m+[m[32m                             _sched :: Int}[m
[32m+[m
[32m+[m[32m-- TH creates some labels for us[m
[32m+[m[32mmkLabel ''GlobState[m
[32m+[m
[32m+[m[32m----- Operations for the state monad -----[m[41m  [m
[32m+[m[32mgetCh :: ChanID -> State GlobState (CType Value (Kont Value))[m
[32m+[m[32mgetCh l = do cs <- Data.Label.Monadic.gets cst[m
[32m+[m[32m             return (contents cs l)[m[41m [m
 [m
[32m+[m[32mmodifyCh :: ChanID -> CType Value (Kont Value) -> State GlobState ()[m
[32m+[m[32mmodifyCh l ct = Data.Label.Monadic.modify cst (\gs -> update gs l ct)[m
 [m
[32m+[m[32mputCh :: State GlobState ChanID[m
[32m+[m[32mputCh = do cs <- Data.Label.Monadic.gets[m
[32m+[m[32m           return[m[41m [m
[32m+[m[41m           [m
[32m+[m[41m         [m
 ----- Some useful instances -----[m
 instance Eq Value where[m
   IntVal a == IntVal b         = a == b[m
[36m@@ -110,294 +99,294 @@[m [minstance Show Value where[m
 [m
 ---------------------------- Start of evaluator ----------------------------[m
 [m
[31m-eval :: Expr -> Env -> Kont Value[m
[31m-[m
[31m------ Basics -----[m
[31m-eval (Number n) _ = return (IntVal n)[m
[31m-[m
[31m-eval (Variable v) env = return (find env v)[m
[31m-[m
[31m-eval (Apply f e) env = [m
[31m-  do Closure id env' body <- eval f env[m
[31m-     v                    <- eval e env[m
[31m-     eval body (define env' id v)[m
[31m-[m
[31m-eval (If cond et ef) env =[m
[31m-  do cond <- eval cond env  [m
[31m-     case cond of[m
[31m-       BoolVal True -> eval et env[m
[31m-       BoolVal False -> eval ef env[m
[31m-       _ -> error "Boolean required in conditional"[m
[31m-[m
[31m-eval (Lambda x e1) env = return $ Closure x env e1[m
[31m-[m
[31m-eval (Pipe e1 e2) env = [m
[31m-  do eval e1 env -- we discard the first expression's result[m
[31m-     eval e2 env[m
[31m-[m
[31m-eval (Let d e1) env =[m
[31m-  do env' <- elab d env [m
[31m-     eval e1 env'[m
[31m-[m
[31m------ Pattern matching -----[m
[31m-eval (Injector name args) env = [m
[31m-  do vs <- values evs [m
[31m-     return $ Injection name vs[m
[31m-  where evs = map (`eval` env) args[m
[31m-[m
[31m-eval (Match ex pats) env = [m
[31m-  do v <- eval ex env [m
[31m-     case matchpat v pats env of[m
[31m-       Just (pex, env') -> eval pex env'[m
[31m-       Nothing          -> return $ Injection "ExcMatch" [][m
[31m-[m
[31m------ Concurrency -----[m
[31m-eval (Send ce ve) env =[m
[31m-  do v <- eval (SendP ce ve) env[m
[31m-     case v of [m
[31m-       Exception _ -> shift pX $ \_ -> return v[m
[31m-       _           -> return v[m
[31m-[m
[31m-eval (SendP ce ve) env = [m
[31m-  shift pP$ \rest -> [m
[31m-  do [m
[31m-    ChanHandle l <- eval ce env [m
[31m-    v <- eval ve env [m
[31m-    sus <- lift $ -- descend to the state monad, to see if we suspend or not[m
[31m-      get l >>= \ chanState -> [m
[31m-        -- based on the state, we decide what the next state is[m
[31m-        case chanState of [m
[31m-          Empty -> [m
[31m-            do put l (WR v rest)[m
[31m-               return $ Halted l[m
[31m-          Ready res _ -> [m
[31m-            do put l $ Ready res (WR v rest)[m
[31m-               return $ Halted l[m
[31m-          WW rk -> [m
[31m-            do put l $ Ready (rk v) Empty[m
[31m-               return $ Resume (rest Unit)[m
[31m-          Closed -> [m
[31m-            return (Resume $ rest (Exception $ Injection "ExcClosed" []))[m
[31m-    case sus of [m
[31m-      Resume res -> res              -- resume execution, no scheduler involved[m
[31m-      Halted init_cst -> return sus  -- return to scheduler[m
[31m-[m
[31m--- The code for Receive is almost identical to the one for Send[m
[31m-eval (Receive ce) env =[m
[31m-  do v <- eval (ReceiveP ce) env[m
[31m-     case v of [m
[31m-       Exception _ -> (shift pX $ \_ -> return v)[m
[31m-       _           -> return v[m
[31m-[m
[31m-eval (ReceiveP ce) env = [m
[31m-  shift pP$ \rest ->[m
[31m-  do [m
[31m-    ChanHandle l <- eval ce env[m
[31m-    sus <- lift $ [m
[31m-      get l >>= \ chanState -> [m
[31m-        case chanState of [m
[31m-          Empty -> [m
[31m-            do put l (WW rest)[m
[31m-               return $ Halted l[m
[31m-          Ready res _ -> [m
[31m-            do put l $ Ready res (WW rest)[m
[31m-               return $ Halted l[m
[31m-          WR v sk -> [m
[31m-            do put l (Ready (sk Unit) Empty) [m
[31m-               return (Resume $ rest v)[m
[31m-          Closed -> [m
[31m-            return (Resume $ rest (Exception $ Injection "ExcClosed" []))[m
[31m-    case sus of [m
[31m-      Resume res -> res [m
[31m-      Halted _ -> return sus [m
[31m-[m
[31m-eval (Parallel cs) env = scheduler (components, []) 0[m
[31m-  where components = map (`createComponent` env) cs[m
[31m-        createComponent c env = pushPrompt pP (eval c env)[m
[31m-[m
[31m-eval NewChan env = [m
[31m-  lift $  [m
[31m-  do l <- new [m
[31m-     put l Empty[m
[31m-     return $ ChanHandle l[m
[31m-[m
[31m-eval (Close c) env = [m
[31m-  do[m
[31m-    ChanHandle l <- eval c env[m
[31m-    lift $ [m
[31m-      get l >>= \ chanState -> case chanState of [m
[31m-        Empty        -> put l Closed[m
[31m-        Closed       -> error "already closed"[m
[31m-        Ready res _  -> put l (Ready res Closed)[m
[31m-        WR _ wk      -> put l (Ready (wk (Exception (Injection "ExcClosed" [])))[m
[31m-                                     Closed)[m
[31m-        WW rk        -> put l (Ready (rk (Exception (Injection "ExcClosed" [])))[m
[31m-                                     Closed)[m
[31m-    return Unit[m
[31m-[m
[31m------ Exception handling -----[m
[31m-eval (TryCatch ex pats) env =   [m
[31m-  do [m
[31m-    -- First we delimit the context in which we evaluate the expression. If [m
[31m-    -- we end in an error, we essentially discard this computation, since we [m
[31m-    -- discard everything up to the closest `px' prompt.[m
[31m-    val <- pushPrompt pX (eval ex env)[m
[31m-    -- Check whether we have ended with an exception or not.[m
[31m-    case val of[m
[31m-      Exception e -> case matchpat e pats env of[m
[31m-                      Just (pex, env') -> eval pex env'[m
[31m-                      -- If no handler handles our error, propagate[m
[31m-                      Nothing          -> shift pX $ \_ -> return $ Exception e[m
[31m-      _           -> return val -- No error, so just return the value.[m
[32m+[m[32m-- eval :: Expr -> Env -> Kont Value[m
[32m+[m
[32m+[m[32m-- ----- Basics -----[m
[32m+[m[32m-- eval (Number n) _ = return (IntVal n)[m
[32m+[m
[32m+[m[32m-- eval (Variable v) env = return (find env v)[m
[32m+[m
[32m+[m[32m-- eval (Apply f e) env =[m[41m [m
[32m+[m[32m--   do Closure id env' body <- eval f env[m
[32m+[m[32m--      v                    <- eval e env[m
[32m+[m[32m--      eval body (define env' id v)[m
[32m+[m
[32m+[m[32m-- eval (If cond et ef) env =[m
[32m+[m[32m--   do cond <- eval cond env[m[41m  [m
[32m+[m[32m--      case cond of[m
[32m+[m[32m--        BoolVal True -> eval et env[m
[32m+[m[32m--        BoolVal False -> eval ef env[m
[32m+[m[32m--        _ -> error "Boolean required in conditional"[m
[32m+[m
[32m+[m[32m-- eval (Lambda x e1) env = return $ Closure x env e1[m
[32m+[m
[32m+[m[32m-- eval (Pipe e1 e2) env =[m[41m [m
[32m+[m[32m--   do eval e1 env -- we discard the first expression's result[m
[32m+[m[32m--      eval e2 env[m
[32m+[m
[32m+[m[32m-- eval (Let d e1) env =[m
[32m+[m[32m--   do env' <- elab d env[m[41m [m
[32m+[m[32m--      eval e1 env'[m
[32m+[m
[32m+[m[32m-- ----- Pattern matching -----[m
[32m+[m[32m-- eval (Injector name args) env =[m[41m [m
[32m+[m[32m--   do vs <- values evs[m[41m [m
[32m+[m[32m--      return $ Injection name vs[m
[32m+[m[32m--   where evs = map (`eval` env) args[m
[32m+[m
[32m+[m[32m-- eval (Match ex cases) env =[m[41m [m
[32m+[m[32m--   do v <- eval ex env[m[41m [m
[32m+[m[32m--      case matchpat v cases env of[m
[32m+[m[32m--        Just (pex, env') -> eval pex env'[m
[32m+[m[32m--        Nothing          -> return $ Injection "ExcMatch" [][m
[32m+[m
[32m+[m[32m-- ----- Concurrency -----[m
[32m+[m[32m-- eval (Send ce ve) env =[m
[32m+[m[32m--   do v <- eval (SendP ce ve) env[m
[32m+[m[32m--      case v of[m[41m [m
[32m+[m[32m--        Exception _ -> shift pX $ \_ -> return v[m
[32m+[m[32m--        _           -> return v[m
[32m+[m
[32m+[m[32m-- eval (SendP ce ve) env =[m[41m [m
[32m+[m[32m--   shift pP$ \rest ->[m[41m [m
[32m+[m[32m--   do[m[41m [m
[32m+[m[32m--     ChanHandle l <- eval ce env[m[41m [m
[32m+[m[32m--     v <- eval ve env[m[41m [m
[32m+[m[32m--     sus <- lift $ -- descend to the state monad, to see if we suspend or not[m
[32m+[m[32m--       getCh l >>= \ chanState ->[m[41m [m
[32m+[m[32m--         -- based on the state, we decide what the next state is[m
[32m+[m[32m--         case chanState of[m[41m [m
[32m+[m[32m--           Empty ->[m[41m [m
[32m+[m[32m--             do putCh l (WR v rest)[m
[32m+[m[32m--                return $ Halted l[m
[32m+[m[32m--           Ready res _ ->[m[41m [m
[32m+[m[32m--             do putCh l $ Ready res (WR v rest)[m
[32m+[m[32m--                return $ Halted l[m
[32m+[m[32m--           WW rk ->[m[41m [m
[32m+[m[32m--             do putCh l $ Ready (rk v) Empty[m
[32m+[m[32m--                return $ Resume (rest Unit)[m
[32m+[m[32m--           Closed ->[m[41m [m
[32m+[m[32m--             return (Resume $ rest (Exception $ Injection "ExcClosed" []))[m
[32m+[m[32m--     case sus of[m[41m [m
[32m+[m[32m--       Resume res -> res              -- resume execution, no scheduler involved[m
[32m+[m[32m--       Halted _   -> return sus       -- return to scheduler[m
[32m+[m
[32m+[m[32m-- -- The code for Receive is almost identical to the one for Send[m
[32m+[m[32m-- eval (Receive ce) env =[m
[32m+[m[32m--   do v <- eval (ReceiveP ce) env[m
[32m+[m[32m--      case v of[m[41m [m
[32m+[m[32m--        Exception _ -> (shift pX $ \_ -> return v)[m
[32m+[m[32m--        _           -> return v[m
[32m+[m
[32m+[m[32m-- eval (ReceiveP ce) env =[m[41m [m
[32m+[m[32m--   shift pP$ \rest ->[m
[32m+[m[32m--   do[m[41m [m
[32m+[m[32m--     ChanHandle l <- eval ce env[m
[32m+[m[32m--     sus <- lift $[m[41m [m
[32m+[m[32m--       getCh l >>= \ chanState ->[m[41m [m
[32m+[m[32m--         case chanState of[m[41m [m
[32m+[m[32m--           Empty ->[m[41m [m
[32m+[m[32m--             do putCh l (WW rest)[m
[32m+[m[32m--                return $ Halted l[m
[32m+[m[32m--           Ready res _ ->[m[41m [m
[32m+[m[32m--             do putCh l $ Ready res (WW rest)[m
[32m+[m[32m--                return $ Halted l[m
[32m+[m[32m--           WR v sk ->[m[41m [m
[32m+[m[32m--             do putCh l (Ready (sk Unit) Empty)[m[41m [m
[32m+[m[32m--                return (Resume $ rest v)[m
[32m+[m[32m--           Closed ->[m[41m [m
[32m+[m[32m--             return (Resume $ rest (Exception $ Injection "ExcClosed" []))[m
[32m+[m[32m--     case sus of[m[41m [m
[32m+[m[32m--       Resume res -> res[m[41m [m
[32m+[m[32m--       Halted _ -> return sus[m[41m [m
[32m+[m
[32m+[m[32m-- eval (Parallel cs) env = scheduler (components, []) 0[m
[32m+[m[32m--   where components = map (`createComponent` env) cs[m
[32m+[m[32m--         createComponent c env = pushPrompt pP (eval c env)[m
[32m+[m
[32m+[m[32m-- eval NewChan env =[m[41m [m
[32m+[m[32m--   lift $[m[41m  [m
[32m+[m[32m--   do l <- newCh[m[41m [m
[32m+[m[32m--      putCh l Empty[m
[32m+[m[32m--      return $ ChanHandle l[m
[32m+[m
[32m+[m[32m-- eval (Close c) env =[m[41m [m
[32m+[m[32m--   do[m
[32m+[m[32m--     ChanHandle l <- eval c env[m
[32m+[m[32m--     lift $[m[41m [m
[32m+[m[32m--       getCh l >>= \ chanState -> case chanState of[m[41m [m
[32m+[m[32m--         Empty        -> putCh l Closed[m
[32m+[m[32m--         Closed       -> error "already closed"[m
[32m+[m[32m--         Ready res _  -> putCh l (Ready res Closed)[m
[32m+[m[32m--         WR _ wk      -> putCh l (Ready (wk (Exception (Injection "ExcClosed" [])))[m
[32m+[m[32m--                                      Closed)[m
[32m+[m[32m--         WW rk        -> putCh l (Ready (rk (Exception (Injection "ExcClosed" [])))[m
[32m+[m[32m--                                      Closed)[m
[32m+[m[32m--     return Unit[m
[32m+[m
[32m+[m[32m-- ----- Exception handling -----[m
[32m+[m[32m-- eval (TryCatch ex pats) env =[m[41m   [m
[32m+[m[32m--   do[m[41m [m
[32m+[m[32m--     -- First we delimit the context in which we evaluate the expression. If[m[41m [m
[32m+[m[32m--     -- we end in an error, we essentially discard this computation, since we[m[41m [m
[32m+[m[32m--     -- discard everything up to the closest `px' prompt.[m
[32m+[m[32m--     val <- pushPrompt pX (eval ex env)[m
[32m+[m[32m--     -- Check whether we have ended with an exception or not.[m
[32m+[m[32m--     case val of[m
[32m+[m[32m--       Exception e -> case matchpat e pats env of[m
[32m+[m[32m--                       Just (pex, env') -> eval pex env'[m
[32m+[m[32m--                       -- If no handler handles our error, propagate[m
[32m+[m[32m--                       Nothing          -> shift pX $ \_ -> return $ Exception e[m
[32m+[m[32m--       _           -> return val -- No error, so just return the value.[m
     [m
[31m-eval (Throw th) env = [m
[31m-  shift pX $ \_ ->[m
[31m-  do v <- eval th env [m
[31m-     case v of[m
[31m-       Injection n vs -> return $ Exception v[m
[31m-       _              -> error "Must throw a sum type"[m
[31m-[m
[31m------ Primitive operations -----[m
[31m-eval (BinPrim bop e1 e2) env = case bop of[m
[31m-  Plus -> arithmeticBOP (+) e1 e2 env[m
[31m-  Minus -> arithmeticBOP (-) e1 e2 env[m
[31m-  Times -> arithmeticBOP (*) e1 e2 env[m
[31m-  Div -> arithmeticBOP (div) e1 e2 env[m
[31m-  Mod -> arithmeticBOP (mod) e1 e2 env[m
[31m-  And -> logicBOP (&&) e1 e2 env[m
[31m-  Or -> logicBOP (||) e1 e2 env[m
[31m-  Equal -> do v1 <- eval e1 env [m
[31m-              v2 <- eval e2 env [m
[31m-              return $ BoolVal (v1 == v2)[m
[31m-[m
[31m-eval (MonPrim mop e) env = [m
[31m-  case mop of[m
[31m-    Neg -> [m
[31m-      do IntVal n <- eval e env [m
[31m-         return $ IntVal (-n)[m
[31m-[m
[31m--- Helper functions that abstract the pattern of evaluation for [m
[31m--- binary primitive operations[m
[31m-arithmeticBOP :: (Integer -> Integer -> Integer) -> [m
[31m-                 Expr -> Expr -> Env -> Kont Value[m
[31m-arithmeticBOP op e1 e2 env = [m
[31m-  do IntVal n1 <- eval e1 env [m
[31m-     IntVal n2 <- eval e2 env  [m
[31m-     return $ IntVal (op n1 n2)[m
[31m-[m
[31m-logicBOP :: (Bool -> Bool -> Bool) -> [m
[31m-            Expr -> Expr -> Env -> Kont Value[m
[31m-logicBOP funcop e1 e2 env = [m
[31m-  do BoolVal b1 <- eval e1 env [m
[31m-     BoolVal b2 <- eval e2 env [m
[31m-     return $ BoolVal (funcop b1 b2)[m
[31m-[m
[31m------ Environment expansion -----[m
[31m-elab :: Defn -> Env -> Kont Env[m
[31m-elab (Val x e) env =[m
[31m-  do v <- eval e env [m
[31m-     return (define env x v)[m
[31m-elab (Rec x e) env =[m
[31m-  case e of[m
[31m-    Lambda fp body -> return env' [m
[31m-      where env' = define env x (Closure fp env' body)[m
[31m-    _ -> error "RHS of letrec must be a lambda"[m
[31m-elab (Data _ ctors) env = foldM (\ env' cdef -> elab cdef env') env ctors[m
[31m-[m
[31m------ Scheduler -----[m
[31m-scheduler :: ([Kont Value], [Kont Value]) -> Int -> Kont Value[m
[31m-scheduler ([], rs) w = if w == 0 [m
[31m-                       then [m
[31m-                        do vs <- values rs[m
[31m-                           return $ Tuple (reverse vs)[m
[31m-                       else scheduler (reverse rs, []) w[m
[31m-scheduler ((k:ks), rs) w = k >>= (\v -> case v of [m
[31m-    Halted l     -> scheduler (ks, (return $ Waiting l):rs) (w + 1)[m
[31m-    Waiting l    -> lift (get l >>= (\cst -> case cst of [m
[31m-                      Ready sk next -> put l next >>= (\() -> return $ Left sk)[m
[31m-                      _             -> return $ Right (return $ Waiting l)[m
[31m-                    )) >>= (\val -> case val of [m
[31m-                      Left r -> scheduler ((r:ks), rs) (w - 1)[m
[31m-                      Right r -> scheduler (ks, (r:rs)) w[m
[31m-                    )[m
[31m-    v            -> scheduler (ks, (return v:rs)) w[m
[31m-  )[m
[31m-[m
[31m------ Helpers -----[m
[31m-values :: [Kont Value] -> Kont [Value][m
[31m-values [] = return [][m
[31m-values (c:cvs) = [m
[31m-  do v <- c [m
[31m-     vs <- values cvs [m
[31m-     return (v:vs)[m
[31m-[m
[31m--- TODO: Fix no error when undefined exception because of lazyness[m
[31m--- Expr for the following two functions is a pattern (leaves are variables)[m
[31m--- Note: while Pattern in the signatures below is a type synonym for Expr, [m
[31m--- we require that it is restricted to `Variable' and `Apply ...', where the[m
[31m--- `Apply' would yield an injection. This could have been handled in a [m
[31m--- cleaner manner, but for ease of understanding we have imposed this [m
[31m--- "soft" restriction.  [m
[31m-matchpat :: Value -> [Pattern] -> Env -> Maybe (Expr, Env)[m
[31m-matchpat v [] env = Nothing[m
[31m-matchpat v ((Case pat ex):ps) env = [m
[31m-  case (trymatch v pat env) of[m
[31m-    Just env' -> Just (ex, env')[m
[31m-    Nothing   -> matchpat v ps env[m
[31m-[m
[31m--- The following two mutually recursive functions try[m
[31m--- to recursively match patterns, so we can match arbitrary [m
[31m--- deep patterns[m
[31m-trymatch :: Value -> Pattern -> Env -> Maybe Env[m
[31m-trymatch v (Variable i) env = Just $ define env i v[m
[31m-trymatch (Injection n vs) pat env =[m
[31m-    if n == n' [m
[31m-    then accumBindings vs ps env[m
[31m-    else Nothing[m
[31m-  where [m
[31m-    -- We transform the application to an injection for ease[m
[31m-    Injector n' ps = appToInj pat [] [m
[31m-trymatch a b _ = error $ show a ++ show b[m
[31m-[m
[31m-accumBindings :: [Value] -> [Pattern] -> Env -> Maybe Env[m
[31m-accumBindings [] [] env = Just env[m
[31m-accumBindings (v:vs) (p:ps) env = case trymatch v p env of[m
[31m-  Just env' -> accumBindings vs ps env'[m
[31m-  Nothing   -> Nothing [m
[31m-[m
[31m--- Helper function that [m
[31m-appToInj :: Expr -> [Expr] -> Expr[m
[31m-appToInj (Apply (Variable v) x) ps = Injector v (x:ps)[m
[31m-appToInj (Apply x y) ps = appToInj x (y:ps)[m
[31m-[m
[31m----------------------------- End of evaluator ----------------------------[m
[31m-[m
[31m--- Initial environment, which only exposes primitive data[m
[31m--- We deal with primitive operations during parsing, by converting them into[m
[31m--- non-application expressions, similar to OCaml[m
[31m-init_env :: Env[m
[31m-init_env =[m
[31m-  make_env [[m
[31m-    -- some primitive data [m
[31m-    ("true", BoolVal True), [m
[31m-    ("false", BoolVal False),[m
[31m-    ("unit", Unit),[m
[31m-    -- some primitive exceptions[m
[31m-    ("ExcClosed", Injection "ExcClosed" []),[m
[31m-    ("ExcInvalid", Injection "ExcInvalid" []),[m
[31m-    ("ExcMatch", Injection "ExcMatch" [])][m
[31m-[m
[31m-init_cst :: CST[m
[31m-init_cst = CST empty_cst  [m
[31m-[m
[31m--- Deal with top-state exprs and defs. Observe the nice compositionality: [m
[31m--- first run the (continuation) computation to produce a state computation,[m
[31m--- which when ran produces the new state, together with the desired result.[m
[31m-obey :: Phrase -> ProgState -> (String, ProgState)[m
[31m-obey (Calculate exp) (env, mem) =[m
[31m-  let (v, mem') = (runS . runCC) (pushPrompt pX (eval exp env)) mem in [m
[31m-  (show v, (env, mem'))[m
[31m-obey (Define def) (env, mem) =[m
[31m-  let x = def_lhs def in[m
[31m-  let (env', mem') = (runS . runCC) (elab def env) mem in [m
[31m-  ("Added definition: " ++ x, (env', mem'))[m
[32m+[m[32m-- eval (Throw th) env =[m[41m [m
[32m+[m[32m--   shift pX $ \_ ->[m
[32m+[m[32m--   do v <- eval th env[m[41m [m
[32m+[m[32m--      case v of[m
[32m+[m[32m--        Injection n vs -> return $ Exception v[m
[32m+[m[32m--        _              -> error "Must throw a sum type"[m
[32m+[m
[32m+[m[32m-- ----- Primitive operations -----[m
[32m+[m[32m-- eval (BinPrim bop e1 e2) env = case bop of[m
[32m+[m[32m--   Plus -> arithmeticBOP (+) e1 e2 env[m
[32m+[m[32m--   Minus -> arithmeticBOP (-) e1 e2 env[m
[32m+[m[32m--   Times -> arithmeticBOP (*) e1 e2 env[m
[32m+[m[32m--   Div -> arithmeticBOP (div) e1 e2 env[m
[32m+[m[32m--   Mod -> arithmeticBOP (mod) e1 e2 env[m
[32m+[m[32m--   And -> logicBOP (&&) e1 e2 env[m
[32m+[m[32m--   Or -> logicBOP (||) e1 e2 env[m
[32m+[m[32m--   Equal -> do v1 <- eval e1 env[m[41m [m
[32m+[m[32m--               v2 <- eval e2 env[m[41m [m
[32m+[m[32m--               return $ BoolVal (v1 == v2)[m
[32m+[m
[32m+[m[32m-- eval (MonPrim mop e) env =[m[41m [m
[32m+[m[32m--   case mop of[m
[32m+[m[32m--     Neg ->[m[41m [m
[32m+[m[32m--       do IntVal n <- eval e env[m[41m [m
[32m+[m[32m--          return $ IntVal (-n)[m
[32m+[m
[32m+[m[32m-- -- Helper functions that abstract the pattern of evaluation for[m[41m [m
[32m+[m[32m-- -- binary primitive operations[m
[32m+[m[32m-- arithmeticBOP :: (Integer -> Integer -> Integer) ->[m[41m [m
[32m+[m[32m--                  Expr -> Expr -> Env -> Kont Value[m
[32m+[m[32m-- arithmeticBOP op e1 e2 env =[m[41m [m
[32m+[m[32m--   do IntVal n1 <- eval e1 env[m[41m [m
[32m+[m[32m--      IntVal n2 <- eval e2 env[m[41m  [m
[32m+[m[32m--      return $ IntVal (op n1 n2)[m
[32m+[m
[32m+[m[32m-- logicBOP :: (Bool -> Bool -> Bool) ->[m[41m [m
[32m+[m[32m--             Expr -> Expr -> Env -> Kont Value[m
[32m+[m[32m-- logicBOP funcop e1 e2 env =[m[41m [m
[32m+[m[32m--   do BoolVal b1 <- eval e1 env[m[41m [m
[32m+[m[32m--      BoolVal b2 <- eval e2 env[m[41m [m
[32m+[m[32m--      return $ BoolVal (funcop b1 b2)[m
[32m+[m
[32m+[m[32m-- ----- Environment expansion -----[m
[32m+[m[32m-- elab :: Defn -> Env -> Kont Env[m
[32m+[m[32m-- elab (Val x e) env =[m
[32m+[m[32m--   do v <- eval e env[m[41m [m
[32m+[m[32m--      return (define env x v)[m
[32m+[m[32m-- elab (Rec x e) env =[m
[32m+[m[32m--   case e of[m
[32m+[m[32m--     Lambda fp body -> return env'[m[41m [m
[32m+[m[32m--       where env' = define env x (Closure fp env' body)[m
[32m+[m[32m--     _ -> error "RHS of letrec must be a lambda"[m
[32m+[m[32m-- elab (Data _ ctors) env = foldM (\ env' cdef -> elab cdef env') env ctors[m
[32m+[m
[32m+[m[32m-- ----- Scheduler -----[m
[32m+[m[32m-- scheduler :: ([Kont Value], [Kont Value]) -> Int -> Kont Value[m
[32m+[m[32m-- scheduler ([], rs) w = if w == 0[m[41m [m
[32m+[m[32m--                        then[m[41m [m
[32m+[m[32m--                          do vs <- values rs[m
[32m+[m[32m--                             return $ Tuple (reverse vs)[m
[32m+[m[32m--                        else scheduler (reverse rs, []) w[m
[32m+[m[32m-- scheduler ((k:ks), rs) w = k >>= (\v -> case v of[m[41m [m
[32m+[m[32m--     Halted l     -> scheduler (ks, (return $ Waiting l):rs) (w + 1)[m
[32m+[m[32m--     Waiting l    -> lift (getCh l >>= (\GlobState -> case GlobState of[m[41m [m
[32m+[m[32m--                       Ready sk next -> putCh l next >>= (\() -> return $ Left sk)[m
[32m+[m[32m--                       _             -> return $ Right (return $ Waiting l)[m
[32m+[m[32m--                     )) >>= (\val -> case val of[m[41m [m
[32m+[m[32m--                       Left r -> scheduler ((r:ks), rs) (w - 1)[m
[32m+[m[32m--                       Right r -> scheduler (ks, (r:rs)) w[m
[32m+[m[32m--                     )[m
[32m+[m[32m--     v            -> scheduler (ks, (return v:rs)) w[m
[32m+[m[32m--   )[m
[32m+[m
[32m+[m[32m-- ----- Helpers -----[m
[32m+[m[32m-- values :: [Kont Value] -> Kont [Value][m
[32m+[m[32m-- values [] = return [][m
[32m+[m[32m-- values (c:cvs) =[m[41m [m
[32m+[m[32m--   do v <- c[m[41m [m
[32m+[m[32m--      vs <- values cvs[m[41m [m
[32m+[m[32m--      return (v:vs)[m
[32m+[m
[32m+[m[32m-- -- TODO: Fix no error when undefined exception because of lazyness[m
[32m+[m[32m-- -- Expr for the following two functions is a pattern (leaves are variables)[m
[32m+[m[32m-- -- Note: while Pattern in the signatures below is a type synonym for Expr,[m[41m [m
[32m+[m[32m-- -- we require that it is restricted to `Variable' and `Apply ...', where the[m
[32m+[m[32m-- -- `Apply' would yield an injection. This could have been handled in a[m[41m [m
[32m+[m[32m-- -- cleaner manner, but for ease of understanding we have imposed this[m[41m [m
[32m+[m[32m-- -- "soft" restriction.[m[41m  [m
[32m+[m[32m-- matchpat :: Value -> [Pattern] -> Env -> Maybe (Expr, Env)[m
[32m+[m[32m-- matchpat v [] env = Nothing[m
[32m+[m[32m-- matchpat v ((Case pat ex):ps) env =[m[41m [m
[32m+[m[32m--   case (trymatch v pat env) of[m
[32m+[m[32m--     Just env' -> Just (ex, env')[m
[32m+[m[32m--     Nothing   -> matchpat v ps env[m
[32m+[m
[32m+[m[32m-- -- The following two mutually recursive functions try[m
[32m+[m[32m-- -- to recursively match patterns, so we can match arbitrary[m[41m [m
[32m+[m[32m-- -- deep patterns[m
[32m+[m[32m-- trymatch :: Value -> Pattern -> Env -> Maybe Env[m
[32m+[m[32m-- trymatch v (Variable i) env = Just $ define env i v[m
[32m+[m[32m-- trymatch (Injection n vs) pat env =[m
[32m+[m[32m--     if n == n'[m[41m [m
[32m+[m[32m--     then accumBindings vs ps env[m
[32m+[m[32m--     else Nothing[m
[32m+[m[32m--   where[m[41m [m
[32m+[m[32m--     -- We transform the application to an injection for ease[m
[32m+[m[32m--     Injector n' ps = appToInj pat [][m[41m [m
[32m+[m[32m-- trymatch a b _ = error $ show a ++ show b[m
[32m+[m
[32m+[m[32m-- accumBindings :: [Value] -> [Pattern] -> Env -> Maybe Env[m
[32m+[m[32m-- accumBindings [] [] env = Just env[m
[32m+[m[32m-- accumBindings (v:vs) (p:ps) env = case trymatch v p env of[m
[32m+[m[32m--   Just env' -> accumBindings vs ps env'[m
[32m+[m[32m--   Nothing   -> Nothing[m[41m [m
[32m+[m
[32m+[m[32m-- -- Helper function that[m[41m [m
[32m+[m[32m-- appToInj :: Expr -> [Expr] -> Expr[m
[32m+[m[32m-- appToInj (Apply (Variable v) x) ps = Injector v (x:ps)[m
[32m+[m[32m-- appToInj (Apply x y) ps = appToInj x (y:ps)[m
[32m+[m
[32m+[m[32m-- ---------------------------- End of evaluator ----------------------------[m
[32m+[m
[32m+[m[32m-- -- Initial environment, which only exposes primitive data[m
[32m+[m[32m-- -- We deal with primitive operations during parsing, by converting them into[m
[32m+[m[32m-- -- non-application expressions, similar to OCaml[m
[32m+[m[32m-- init_env :: Env[m
[32m+[m[32m-- init_env =[m
[32m+[m[32m--   make_env [[m
[32m+[m[32m--     -- some primitive data[m[41m [m
[32m+[m[32m--     ("true", BoolVal True),[m[41m [m
[32m+[m[32m--     ("false", BoolVal False),[m
[32m+[m[32m--     ("unit", Unit),[m
[32m+[m[32m--     -- some primitive exceptions[m
[32m+[m[32m--     ("ExcClosed", Injection "ExcClosed" []),[m
[32m+[m[32m--     ("ExcInvalid", Injection "ExcInvalid" []),[m
[32m+[m[32m--     ("ExcMatch", Injection "ExcMatch" [])][m
[32m+[m
[32m+[m[32m-- init_GlobState :: GlobState[m
[32m+[m[32m-- init_GlobState = GlobState empty_GlobState[m[41m  [m
[32m+[m
[32m+[m[32m-- -- Deal with top-state exprs and defs. Observe the nice compositionality:[m[41m [m
[32m+[m[32m-- -- first run the (continuation) computation to produce a state computation,[m
[32m+[m[32m-- -- which when ran produces the new state, together with the desired result.[m
[32m+[m[32m-- obey :: Phrase -> ProgState -> (String, ProgState)[m
[32m+[m[32m-- obey (Calculate exp) (env, mem) =[m
[32m+[m[32m--   let (v, mem') = (runState . runCC) (pushPrompt pX (eval exp env)) mem in[m[41m [m
[32m+[m[32m--   (show v, (env, mem'))[m
[32m+[m[32m-- obey (Define def) (env, mem) =[m
[32m+[m[32m--   let x = def_lhs def in[m
[32m+[m[32m--   let (env', mem') = (runState . runCC) (elab def env) mem in[m[41m [m
[32m+[m[32m--   ("Added definition: " ++ x, (env', mem'))[m
[1mdiff --git a/lang/stack.yaml b/lang/stack.yaml[m
[1mindex ddac32b..76e54cd 100644[m
[1m--- a/lang/stack.yaml[m
[1m+++ b/lang/stack.yaml[m
[36m@@ -34,8 +34,8 @@[m [mpackages:[m
 # These entries can reference officially published versions as well as[m
 # forks / in-progress versions pinned to a git hash. For example:[m
 #[m
[31m-# extra-deps:[m
[31m-# - acme-missiles-0.3[m
[32m+[m[32mextra-deps:[m
[32m+[m[32m- fclabels-2.0.3.3@sha256:9fc5d1e4466c400710d3a1d59e8cad4e659883da1f56ad4c491c52f9080ef626,4438[m
 # - git: https://github.com/commercialhaskell/stack.git[m
 #   commit: e7b331f14bcffb8367cd58fbfc8b40ec7642100a[m
 #[m
[1mdiff --git a/lang/test/tests b/lang/test/tests[m
[1mindex a05fff8..af25612 100644[m
[1m--- a/lang/test/tests[m
[1m+++ b/lang/test/tests[m
[36m@@ -41,4 +41,28 @@[m [mmain;;[m
 [m
 ---------- Pattern matching ----------[m
 data A = B 1 | C 2;;[m
[31m-match C (B (C 4 3)) 4 with C (C x q) y => x | C (B (C x y)) z => x;;[m
\ No newline at end of file[m
[32m+[m[32mmatch C (B (C 4 3)) 4 with C (C x q) y => x | C (B (C x y)) z => x;;[m[41m[m
[32m+[m[41m[m
[32m+[m[41m[m
[32m+[m[32m--- Expected ---[m[41m[m
[32m+[m[32mAdded definition: x[m[41m[m
[32m+[m[32m(23,2,unit)[m[41m[m
[32m+[m[32mAdded definition: x[m[41m[m
[32m+[m[32m234[m[41m[m
[32m+[m[32m<unhandled exception -> ExcClosed>[m[41m[m
[32m+[m[32mAdded definition: x[m[41m[m
[32m+[m[32m<unhandled exception -> ExcClosed>[m[41m[m
[32m+[m[32mAdded definition: c[m[41m[m
[32m+[m[32m(5,2,unit)[m[41m[m
[32m+[m[32mAdded definition: x[m[41m[m
[32m+[m[32mAdded definition: y[m[41m[m
[32m+[m[32m<unhandled exception -> ExcClosed>[m[41m[m
[32m+[m[32mAdded definition: x[m[41m[m
[32m+[m[32mAdded definition: y[m[41m[m
[32m+[m[32m(unit,2,2)[m[41m[m
[32m+[m[32mAdded definition: server[m[41m[m
[32m+[m[32mAdded definition: client[m[41m[m
[32m+[m[32mAdded definition: main[m[41m[m
[32m+[m[32m(unit,1000)[m[41m[m
[32m+[m[32mAdded definition: A[m[41m[m
[32m+[m[32m4[m
\ No newline at end of file[m
[1mdiff --git a/stack.yaml b/stack.yaml[m
[1mindex 59463e7..d17796f 100644[m
[1m--- a/stack.yaml[m
[1m+++ b/stack.yaml[m
[36m@@ -35,7 +35,7 @@[m [mpackages:[m
 # forks / in-progress versions pinned to a git hash. For example:[m
 #[m
 extra-deps:[m
[31m-- CC-delcont-0.2.1.0@sha256:3791184e55c0f59549443f8dde86131b3479f7eb4b540549aceff6db2b2e3006,2276[m
[32m+[m[32m- fclabels-2.0.5@sha256:817006077632bd29e637956154aa33d3c10a59be0791c308cef955eb951b2675,4473[m
 # - acme-missiles-0.3[m
 # - git: https://github.com/commercialhaskell/stack.git[m
 #   commit: e7b331f14bcffb8367cd58fbfc8b40ec7642100a[m
[1mdiff --git a/stack.yaml.lock b/stack.yaml.lock[m
[1mindex f011a77..b1faa6d 100644[m
[1m--- a/stack.yaml.lock[m
[1m+++ b/stack.yaml.lock[m
[36m@@ -5,12 +5,12 @@[m
 [m
 packages:[m
 - completed:[m
[31m-    hackage: CC-delcont-0.2.1.0@sha256:3791184e55c0f59549443f8dde86131b3479f7eb4b540549aceff6db2b2e3006,2276[m
[32m+[m[32m    hackage: fclabels-2.0.5@sha256:817006077632bd29e637956154aa33d3c10a59be0791c308cef955eb951b2675,4473[m
     pantry-tree:[m
[31m-      size: 481[m
[31m-      sha256: 5bd0b5b5318c0ca1707316b138faa323dea5c198ca339d7f00286b50a37cdccb[m
[32m+[m[32m      size: 1008[m
[32m+[m[32m      sha256: 8a9254b7f80c3586d6e51d35c1355e700c3f9b0b3d8e3ae6e6ab939580188e1b[m
   original:[m
[31m-    hackage: CC-delcont-0.2.1.0@sha256:3791184e55c0f59549443f8dde86131b3479f7eb4b540549aceff6db2b2e3006,2276[m
[32m+[m[32m    hackage: fclabels-2.0.5@sha256:817006077632bd29e637956154aa33d3c10a59be0791c308cef955eb951b2675,4473[m
 snapshots:[m
 - completed:[m
     size: 533053[m
